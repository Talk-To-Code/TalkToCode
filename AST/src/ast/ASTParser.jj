/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(ASTParser)package ast;import java.util.*;/**
	@author GAO RISHENG A0101891L
	this class is in charge of translation between all structural command generated
	from the upper layer of this software to respective ASTNodes
	All the grammar rules are defined in this JavaCC class
	Currently only support C-language AST nodes translation
	Future development is to establish a full support to Java and Python
	line 59 - 319 are defined special tokens
	line 320 - 1464 are defined grammar rules for structural commands and how the compiler construct
	respective AST nodes in parsing respective structural commands 
*/public class ASTParser{
  public enum programType { C, P, J }
    private static ASTNode current = new ASTNode();  private static ASTNode program = new ASTNode();

  private static boolean isDebug;  public static void main(String args []) throws ParseException  {    ASTParser parser = new ASTParser(System.in);    //while (true)    //{      //System.out.println("Reading from standard input...");      //System.out.print("Enter an program:\n");

      if(args.length != 1) {
        System.out.println("INVALID INPUT!\nEnter 1 to print output once at the end.\nEnter 0 to print output both at the end and after completion of each statement.\nSystem exiting...");
        System.exit(1);
      }
      
      if(args[0].compareTo("1") == 0) ASTParser.isDebug = false;
      else if(args[0].compareTo("0") == 0) ASTParser.isDebug = true;
      else {
        System.out.println("INVALID INPUT!\nEnter 1 to print output once at the end.\nEnter 0 to print output both at the end and after completion of each statement.\nSystem exiting...");
        System.exit(1);
      }
            try      {        program();        System.out.println("AST construction complete.");      }      catch (Exception e)      {        System.out.println("Not Supported Syntax Format");        System.out.println(e.getMessage());        ASTParser.ReInit(System.in);      }      catch (Error e)      {
        System.out.println("Special Reject Sequence @#$%^&*()!");        System.out.println("Unknown Error Occurs.");        System.out.println(e.getMessage());        //break;      }    //}  }  private static void getStructure(ASTNode current)  {    Stack < ASTNode > stack = new Stack < ASTNode > ();    ASTNode temp = current;    stack.push(temp);    while (temp.parent != null)    {      if (temp.isAblock())      {        stack.push(temp);      }      temp = temp.getParent();    }    int counter = 0;    while (!stack.isEmpty())    {      String indent = "";      for (int i = 0; i < counter; i++)      {        indent += "\t";      }      System.out.println(indent + stack.pop().typeof());      counter++;    }  }  private static void getTree(ASTNode current)  {    ASTNode temp = current;    while (temp.parent != null)    {      temp = temp.getParent();    }    System.out.println(temp.toTree(0));  }}PARSER_END(ASTParser)/**********************************************
 * THE JAVACC TOKEN SPECIFICATION STARTS HERE *
 **********************************************//* JAVACC RESERVED WORDS: These are the only tokens in JavaCC but not in Java */< DEFAULT >TOKEN :{  < _LOOKAHEAD : "LOOKAHEAD" >| < _IGNORE_CASE : "IGNORE_CASE" >| < _PARSER_BEGIN : "PARSER_BEGIN" >| < _PARSER_END : "PARSER_END" >| < _JAVACODE : "JAVACODE" >| < _TOKEN : "TOKEN" >| < _SPECIAL_TOKEN : "SPECIAL_TOKEN" >| < _MORE : "MORE" >| < _SKIP : "SKIP" >| < _TOKEN_MGR_DECLS : "TOKEN_MGR_DECLS" >| < _EOF : "EOF" >}/*
 * The remainder of the tokens are exactly (except for the removal of tokens
 * containing ">>" and "<<") as in the Java grammar and must be diff equivalent
 * (again with the exceptions above) to it.
 *//* WHITE SPACE */< DEFAULT >SKIP :{  " "| "\t"| "\n"| "\r"| "\f"| "/*@egen*/" : AFTER_EGEN}< AFTER_EGEN >SKIP :{  < ~[ ] > : DEFAULT}/* JAVA RESERVED WORDS AND LITERALS */< DEFAULT >TOKEN :{  < ABSTRACT : "abstract" >
| < AS : "as" >| < ASSERT : "assert" >| < BOOLEAN : "boolean" >| < BREAK : "break" >| < BYTE : "byte" >| < CASE : "case" >| < CATCH : "catch" >| < CHAR : "char" >| < CLASS : "class" >| < CONST : "const" >| < CONTINUE : "continue" >| < _DEFAULT : "default" >| < DO : "do" >| < DOUBLE : "double" >| < ELSE : "else" >| < ENUM : "enum" >| < EXTENDS : "extends" >| < FALSE : "false" >| < FINAL : "final" >| < FINALLY : "finally" >| < FLOAT : "float" >| < FOR : "for" >
| < FROM : "from" >| < GOTO : "goto" >| < IF : "if" >| < IMPLEMENTS : "implements" >| < IMPORT : "import" >| < INSTANCEOF : "instanceof" >| < INT : "int" >| < INTERFACE : "interface" >| < LONG : "long" >| < NATIVE : "native" >| < NEW : "new" >| < NULL : "null" >| < PACKAGE : "package" >
| < PASS : "pass" >| < PRIVATE : "private" >| < PROTECTED : "protected" >| < PUBLIC : "public" >| < RETURN : "return" >| < SHORT : "short" >| < STATIC : "static" >| < STRICTFP : "strictfp" >| < SUPER : "super" >| < SWITCH : "switch" >| < SYNCHRONIZED : "synchronized" >| < THIS : "this" >| < THROW : "throw" >| < THROWS : "throws" >| < TRANSIENT : "transient" >| < TRUE : "true" >| < TRY : "try" >
| < TYPEDEF : "typedef" >| < VOID : "void" >| < VOLATILE : "volatile" >| < WHILE : "while" >}/* JAVA LITERALS */< DEFAULT >TOKEN :{  < INTEGER_LITERAL :    < DECIMAL_LITERAL > (["-", "l", "L" ])?  | < HEX_LITERAL > ([ "l", "L" ])?  | < OCTAL_LITERAL > ([ "l", "L" ])? >| < #DECIMAL_LITERAL : (["-"])?[ "1"-"9" ] ([ "0"-"9" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >| < FLOATING_POINT_LITERAL :    < DECIMAL_FLOATING_POINT_LITERAL >  | < HEXADECIMAL_FLOATING_POINT_LITERAL >>| < #DECIMAL_FLOATING_POINT_LITERAL :    (["-"])?([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< DECIMAL_EXPONENT >)? ([ "f", "F", "d", "D" ])?  | "." ([ "0"-"9" ])+ (< DECIMAL_EXPONENT >)? ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ < DECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ (< DECIMAL_EXPONENT >)? [ "f", "F", "d", "D" ] >| < #DECIMAL_EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < #HEXADECIMAL_FLOATING_POINT_LITERAL :    "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ (".")? < HEXADECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])?  | "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])* "." ([ "0"-"9", "a"-"f", "A"-"F" ])+ < HEXADECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])? >| < #HEXADECIMAL_EXPONENT : [ "p", "P" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < CHARACTER_LITERAL :    "\'"    (      ~[ "\'", "\\", "\n", "\r" ]    | "\\"      (        [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]      | [ "0"-"7" ] ([ "0"-"7" ])?      | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]      )    )    "\'" >| < STRING_LITERAL :    "\""    (      ~[ "\"", "\\", "\n", "\r" ]    | "\\"      (        [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]      | [ "0"-"7" ] ([ "0"-"7" ])?      | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]      )    )*    "\"" >}/* SEPARATORS */< DEFAULT >TOKEN :{  < LPAREN : "(" >| < RPAREN : ")" >| < LBRACE : "{" >| < RBRACE : "}" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < SEMICOLON : ";" >| < COMMA : "," >| < DOT : "." >}/* OPERATORS */< DEFAULT >TOKEN :{  < ASSIGN : "=" >| < LT : "<" >| < GT : ">" >| < BANG : "!" >| < TILDE : "~" >| < HOOK : "?" >| < COLON : ":" >| < EQ : "==" >| < LE : "<=" >| < GE : ">=" >| < NE : "!=" >| < SC_OR : "||" >| < SC_AND : "&&" >
| < PY_OR : "or" >
| < PY_AND : "and" >
| < PY_NOT : "not" >
| < IS : "is" >| < INCR : "++" >| < DECR : "--" >| < PLUS : "+" >| < MINUS : "-" >| < STAR : "*" >| < SLASH : "/" >| < BIT_AND : "&" >| < BIT_OR : "|" >| < XOR : "^" >| < REM : "%" >| < PLUSASSIGN : "+=" >| < MINUSASSIGN : "-=" >| < STARASSIGN : "*=" >| < SLASHASSIGN : "/=" >| < ANDASSIGN : "&=" >| < ORASSIGN : "|=" >| < XORASSIGN : "^=" >| < REMASSIGN : "%=" >| < SHIFT_LEFT : "<<" >| < SHIFT_RIGHT : ">>" >}/* keywords */TOKEN :{  < ASSIGNMENT : "#assign" >| < CREATE : "#create" >| < TYPE : "#type" >| < VARIABLE : "#variable" >| < VALUE : "#value" >| < FUNCTION : "#function" >| < WITH : "#with" >| < CONDITION : "#condition" >| < EXPRESSIONS : "#expression" >| < IF_BRANCH_START : "#if_branch_start" >| < IF_BRANCH_END : "#if_branch_end" >
| < ELSEIF_BRANCH_START : "#elseIf_branch_start" >
| < ELSEIF_BRANCH_END : "#elseIf_branch_end" >| < ELSE_BRANCH_START : "#else_branch_start" >| < ELSE_BRANCH_END : "#else_branch_end" >| < PRE : "#pre" >| < POST : "#post" >| < TERMINATOR : ";;" >| < PARAMETER : "#parameter" >| < STRUCT : "#struct" >| < ARRAY : "#array" >| < ACCESS : "#access" >| < ACCESS_END : "#access_end" >| < LABEL : "#label" >| < INDEX : "#indexes" >| < INDEX_END : "#index_end" >| < INCLUDE : "#include" >| < FOR_START : "#for_start" >| < FOR_END : "#for_end" >| < WHILE_START : "#while_start" >| < WHILE_END : "#while_end" >| < SWITCH_START : "#switch_start" >| < SWITCH_END : "#switch_end" >| < CASE_START : "#case_start" >| < CASE_END : "#case_end" >| < FUNCTION_DEC : "#function_declare" >| < FUNCTION_START : "#function_start" >| < FUNCTION_END : "#function_end" >| < STRUCT_DEC : "#struct_declare" >| < STRUCT_START : "#struct_start" >| < STRUCT_END : "#struct_end" >| < PROGRAM_END : "#program_end" >| < PROGRAM_C : "#c_program" >
| < PROGRAM_P : "#p_program" >| < DECLARE_END : "#dec_end" >| < DIMENSION : "#dimension" >| < PARAMETER_A : "#parameter_a" >| < TREE : "#tree" >
| < COMMENT : "#comment" >
| < COMMENT_END : "#comment_end" >
| < LIST : "#list" >
| < TUPLE : "#tuple" >
| < DICTIONARY : "#dictionary" >
| < KEY : "#key" >
| < PARENT : "#parent" >
| < CLASS_START : "#class_start" >
| < CLASS_END : "#class_end" >
| < EXCEPTION : "#exception" >
| < CATCH_START : "#catch_start" >
| < CATCH_END : "#catch_end" >
| < FINALLY_END : "#finally_end" >
| < WITH_START : "#with_start" >
| < WITH_END : "#with_end" >
| < LAMBDA : "#lambda" >
| < LAMBDA_END: "#lambda_end" >
| < STRING : "#string" >}TOKEN :{  < C_TYPES_MODIFIERS_SIGNED : "signed" >| < C_TYPES_MODIFIERS_UNSIGNED : "unsigned" >}/* IDENTIFIERS */TOKEN :{  < IDENTIFIER : < LETTER > (< PART_LETTER >)* >| < #LETTER : [ "$", "A"-"Z", "_", "a"-"z" ] >| < #PART_LETTER : [ "$", "0"-"9", "A"-"Z", "_", "a"-"z" ] >}String variable() :{  Token var;}{  < VARIABLE > var = < IDENTIFIER >  {    return var.image;  }}String infixOperators() :{  Token n;}{  n = < PLUS >  {    return n.image;  }| n = < MINUS >  {    return n.image;  }| n = < STAR >  {    return n.image;  }| n = < SLASH >  {    return n.image;  }| n = < LT >  {    return n.image;  }| n = < GT >  {    return n.image;  }| n = < EQ >  {    return n.image;  }| n = < LE >  {    return n.image;  }| n = < GE >  {    return n.image;  }| n = < NE >  {    return n.image;  }| n = < SC_OR >  {    return n.image;  }| n = < SC_AND >  {    return n.image;  }
| n = < PY_OR >
  {
    return n.image;
  }
| n = < PY_AND >
  {
    return n.image;
  }
| n = < IS >
  {    return n.image;
  }| n = < BIT_AND >  {    return n.image;  }| n = < BIT_OR >  {    return n.image;  }| n = < XOR >  {    return n.image;  }| n = < REM >  {    return n.image;  }| n = < SHIFT_LEFT >  {    return n.image;  }| n = < SHIFT_RIGHT >  {    return n.image;  }}String compoundOperators() :{  Token n;}{  n = < PLUSASSIGN >  {    return n.image;  }| n = < MINUSASSIGN >  {    return n.image;  }| n = < STARASSIGN >  {    return n.image;  }| n = < SLASHASSIGN >  {    return n.image;  }| n = < REMASSIGN >  {    return n.image;  }| n = < ORASSIGN >  {    return n.image;  }| n = < ANDASSIGN >  {    return n.image;  }| n = < XORASSIGN >  {    return n.image;  }}String prefixOperators() :{  Token n;}{  n = < BANG >  {    return n.image;  }| n = < TILDE >  {    return n.image;  }| n = < BIT_AND >  {    return n.image;  }
| n = < PY_NOT >
  {    return n.image;
  }}String incrDecrOperators() :{  Token n;}{  n = < INCR >  {    return n.image;  }| n = < DECR >  {    return n.image;  }}String catchModifier() :{  Token n;}{  n = < ABSTRACT >  {    return n.image;  }| n = < PRIVATE >  {    return n.image;  }| n = < PROTECTED >  {    return n.image;  }| n = < PUBLIC >  {    return n.image;  }| n = < STATIC >  {    return n.image;  }| n = < FINAL >  {    return n.image;  }| n = < SYNCHRONIZED >  {    return n.image;  }| n = < VOLATILE >  {    return n.image;  }| n = < CONST >  {    return n.image;  }}ASTExpressionUnitLiteral value(programType pType) :{  Token n;  Token sign;  ASTExpressionUnitLiteral valueNode;}{  n = < INTEGER_LITERAL >  {    valueNode = new ASTExpressionUnitLiteral(n.image);    //System.out.println(valueNode.print());
    return valueNode;  }| n = < FLOATING_POINT_LITERAL >  {    valueNode = new ASTExpressionUnitLiteral(n.image);    //System.out.println(valueNode.print());
    return valueNode;  }| n = < CHARACTER_LITERAL >  {    valueNode = new ASTExpressionUnitLiteral(n.image);    //System.out.println(valueNode.print());
    return valueNode;  }| n = < STRING_LITERAL >  {    valueNode = new ASTExpressionUnitLiteral(n.image);    return valueNode;  }| n = < TRUE >  {
    valueNode = (pType == programType.P) ? new ASTExpressionUnitLiteral("True") : new ASTExpressionUnitLiteral(n.image);    return valueNode;  }| n = < FALSE >  {    valueNode = (pType == programType.P) ? new ASTExpressionUnitLiteral("False") : new ASTExpressionUnitLiteral(n.image);    return valueNode;  }}String primitive_typesJ() :{  Token n;}{  (    n = < BYTE >    {      return n.image;    }  | n = < INT >    {      return n.image;    }  | n = < CHAR >    {      return n.image;    }  | n = < DOUBLE >    {      return n.image;    }  | n = < FLOAT >    {      return n.image;    }  | n = < BOOLEAN >    {      return n.image;    }  )}String primitive_typesC() :{  Token n;  Token second;  Token third;}{  (    n = < INT >    {      return n.image;    }  | n = < CHAR >    {      return n.image;    }  | n = < LONG >    {      return n.image;    }  | n = < SHORT >    {      return n.image;    }  | n = < DOUBLE >    {      return n.image;    }  | n = < FLOAT >    {      return n.image;    }  | n = < C_TYPES_MODIFIERS_SIGNED >    {      return n.image;    }
  | n = < C_TYPES_MODIFIERS_UNSIGNED >
  	{
  	  return n.image;
  	}  )}String types_C() :{  String token;  String result = "";  Token n;}{  (< STRUCT >)? n = < IDENTIFIER >  {    return n.image + " ";  }|  (    token = primitive_typesC()    {      result += token + " ";    }  )+  {    return result;  }}String typesJ() :{  String type;  Token n;}{  n = < IDENTIFIER >  {    return n.image;  }| type = primitive_typesJ()  {    return type;  }}ASTDeclarationStatement create_variable(programType pType) :{  String type_token = "";  Token name;  String id;
  ASTExpressionUnitAccess access;
  ASTExpressionUnitPointer p;  ASTDeclarationStatement result;  ASTExpressionUnitIdentifier var;  ASTExpression exp = null;  String temp;  ArrayList < String > modifiers = new ArrayList < String > ();}{  < CREATE >  (    temp = catchModifier()    {      modifiers.add(temp);    }  )*
  (    type_token = types_C()
  )?  {
    switch (pType) {
      case C:
      	if (type_token == "") throw new ParseException("Must declare type in C and Java!\n");
      	result = new ASTDeclarationStatementC(type_token);	    for (String s : modifiers)	    {	      ((ASTDeclarationStatementC) result).addModifier(s);	    }
	    break;
	  case P:
	  	result = new ASTDeclarationStatementP();
	  	break;
	  default:
	  	result = new ASTDeclarationStatement();
	  	break;
	 }  }  (    (
      (        id = variable()
      | p = pointer(pType)
      	{
      	  if(pType != programType.C) throw new ParseException("Not supported in Python or Java!\n");
      	  id = p.toSyntax();
      	}
      | access = access(pType)
      	{
      	  if(pType != programType.P) throw new ParseException("Not supported in C or Java!\n");
      	  id = access.toSyntax();
      	}
      )      (        exp = expression(pType)      )?      < DECLARE_END >      {        if (exp == null)        {
          switch (pType) {
            case C:
            	((ASTDeclarationStatementC) result).addVariableWithoutDeclaration(new ASTExpressionUnitIdentifier(id));
            	break;
            case P:
            	throw new ParseException("Python variables have to be initialised!\n");
            	break;
          }        }        else        {
          switch (pType) {
            case C:
            	((ASTDeclarationStatementC) result).addVariableWithDeclaration(new ASTExpressionUnitIdentifier(id), exp);
            	break;
            case P:
            	((ASTDeclarationStatementP) result).AddAVariable(new ASTExpressionAssignment(new ASTExpressionUnitIdentifier(id), exp, "="));
            	break;
          }          exp = null;        }      }    )  |    (      < ARRAY > < VARIABLE > name = < IDENTIFIER >      {
        if(pType == programType.P) throw new ParseException("Not supported in Python!\n");        ASTExpressionUnitIdentifierArrayObject array = new ASTExpressionUnitIdentifierArrayObject(new ASTExpressionUnitIdentifier(name.image));      }      (        < INDEX > exp = value(pType) < INDEX_END >        {          array.addIndex(exp);
          exp = null;        }      )+
      (
        exp = fragment(pType)
      )?      < DECLARE_END >    )
    {
      if(exp == null) ((ASTDeclarationStatementC) result).addVariableWithoutDeclaration(array);
      else {
        if(exp instanceof ASTExpressionUnitLiteralArray) ((ASTDeclarationStatementC) result).addVariableWithDeclaration(array, exp);
        else throw new ParseException("Must be initialised to an array!\n");
      }
      exp = null;
    }  )+  < TERMINATOR >  {    return result;  }}
ASTExpressionUnitAccess access(programType pType) :
{
  Token var = new Token();
  ASTExpression result = new ASTExpression();
}
{
  < ACCESS >
  {
    ArrayList < ASTExpressionUnit > ids = new ArrayList < ASTExpressionUnit > ();
  }
  (
    (result = fragment(pType))
    {
      ids.add((ASTExpressionUnit) result);
    }
  |	var = < IDENTIFIER >
    {
      ids.add(new ASTExpressionUnitIdentifier(var.image));
    }
  | var = < NEW >
    {
      ids.add(new ASTExpressionUnitIdentifier(var.image));
    }
  )
  (
    result = fragment(pType)
	{
      ids.add((ASTExpressionUnit) result);
	}
  | var = < IDENTIFIER >
    {
      ids.add(new ASTExpressionUnitIdentifier(var.image));
    }
  | var = < NEW >
    {
      ids.add(new ASTExpressionUnitIdentifier(var.image));
    }
  )+
  < ACCESS_END >
  {
    return ASTExpressionUnitAccess.generateNestedAccess(ids);
  }
}

ASTExpressionUnitFunctionCall func(programType pType) :
{
  Token var = new Token();
  ASTExpression parameters = new ASTExpression();
  ASTExpressionUnitAccess access;
  ASTExpressionUnitFunctionCall call;
}
{
  < FUNCTION >
  (
    var = < IDENTIFIER >
    {
      call = new ASTExpressionUnitFunctionCall(var.image);
      //System.out.println(var.image);
    }
  |
  	var = < FLOAT >
  	{
  	  call = new ASTExpressionUnitFunctionCall(var.image);
  	}
  |
  	var = < INT >
  	{
  	  call = new ASTExpressionUnitFunctionCall(var.image);
  	}
  |
    access = access(pType)
 	{
	  call = new ASTExpressionUnitFunctionCall(access.toSyntax());
	}
  )
  < LPAREN >
  (
    < PARAMETER > parameters = expression(pType)
    {
      call.addParameter(parameters);
    }
    (      var = < IDENTIFIER >
      {
        call.addParamName(var.image);
      }
    )?
  )*
  < RPAREN >
  {
    return call;
  }
}

ASTExpressionUnitPointer pointer(programType pType) :
{
  ASTExpression exp;
}
{
  (
    < STAR >
    {
      if(pType != programType.C) throw new ParseException("Not supported in Java and Python!");
    }
    exp = fragment(pType)
    {
      return new ASTExpressionUnitPointer((ASTExpressionUnit) exp);
    }
  )
}
ASTExpression fragment(programType pType) :{  Token var = new Token();  String id;  Token check = new Token();  ASTExpressionUnitLiteral v = new ASTExpressionUnitLiteral();  ASTExpression parameters = new ASTExpression();  ASTExpression result = new ASTExpression();
  Token identifier = new Token();
  ASTExpressionUnitAccess access;
  ASTExpressionUnitFunctionCall call;
  ASTExpressionUnitLambda lambda;
  ASTExpressionUnitPointer p;}{
  p = pointer(pType)
  {
    return p;
  }
|   (    < VALUE > v = value(pType)  )  {    //System.out.println(v.toSyntax());
    return v;  }| id = variable()  {    return new ASTExpressionUnitIdentifier(id);  }|  call = func(pType)  {    return call;  }|  (    check = < LPAREN > result = expression(pType) < RPAREN >  )  {    result.quote();    return result;  }| < LBRACE >  {    ASTExpressionUnitLiteral arr;
    ASTExpressionUnitLiteral key;
    ASTExpression value;  }
  (
    (      < ARRAY >
      {
        arr = new ASTExpressionUnitLiteralArray(ASTExpressionUnitLiteralArray.bracketType.CURLY);
      }
    | < LIST >
      {
        if (pType != programType.P) throw new ParseException("Not supported in C and Java!");
        arr = new ASTExpressionUnitLiteralArray(ASTExpressionUnitLiteralArray.bracketType.SQUARE); 
      }
    | < TUPLE >
      {
        if (pType != programType.P) throw new ParseException("Not supported in C and Java!");
        arr = new ASTExpressionUnitLiteralArray(ASTExpressionUnitLiteralArray.bracketType.ROUND); 
      }
    )
    (
      < PARAMETER > parameters = expression(pType)
      {
        ((ASTExpressionUnitLiteralArray) arr).addValue(parameters);
      }
    )*
  | < DICTIONARY >
  	{
  	  if (pType != programType.P) throw new ParseException("Not supported in C and Java!");
  	  arr = new ASTExpressionUnitLiteralDictionary();
  	}
  	(  	  < KEY > key = value(pType) < VALUE > value = expression(pType)
  	  {
  	    ((ASTExpressionUnitLiteralDictionary) arr).addValue(key, value);
  	  }
  	)*  )  < RBRACE >
  {    return arr;
  }| < ARRAY >
  {
    ASTExpressionUnitIdentifierArrayObject array;
  }
  (    var = < IDENTIFIER >
    {
      array = new ASTExpressionUnitIdentifierArrayObject(new ASTExpressionUnitIdentifier(var.image));
    }
  | call = func(pType)
  	{
  	  array = new ASTExpressionUnitIdentifierArrayObject(call);
  	}
  |  access = access(pType)
 	{
 	  array = new ASTExpressionUnitIdentifierArrayObject(access);
 	}
  )  (    < INDEX > parameters = expression(pType) < INDEX_END >
    {
      array.addIndex(parameters);
    }  )+
  {    return array;
  }| access = access(pType)  {    return access;  }
| < LAMBDA >
  {    if(pType == programType.C) throw new ParseException("Not supported in C!\n");
    lambda = new ASTExpressionUnitLambda();
  }
  (
    var = < IDENTIFIER >
    {
      lambda.addParameter(var.image);
    }
  )*
  parameters = expression(pType)
  {    lambda.setExpression(parameters);
  }
  < LAMBDA_END >
  {    return lambda;
  }
| < TYPE > id = types_C() < LPAREN > parameters = expression(pType) < RPAREN >
  {
    if(pType == programType.P) throw new ParseException("Not supported in Python!\n");    return new ASTExpressionUnitTypeCast(id, parameters);
  }}ASTExpression term(programType pType) :{  ArrayList < String > operators = new ArrayList < String > ();  ArrayList < ASTExpression > operands = new ArrayList < ASTExpression > ();  String operator = null;  ASTExpression operand1;  ASTExpression operand2 = new ASTExpression();  ASTExpression result;}{  operand1 = fragment(pType)  (    operator = infixOperators()    {
      if (pType == programType.P && (operator == "||" || operator == "&&")) throw new ParseException("Not supported in Python!\n");
      else if (pType != programType.P && (operator == "or" || operator == "and" || operator == "is")) throw new ParseException("Not supported in C and Java!\n");      operators.add(operator);    }    operand2 = fragment(pType)    {      operands.add(operand2);    }  )*  {    if (operator == null || operators.isEmpty())    {      result = operand1;      return result;    }    result = new ASTExpression();    while (!operators.isEmpty())    {      result = new ASTExpressionInfixOperation(operators.remove(0), operand1, operands.remove(0));      operand1 = result;    }    return result;  }}ASTExpression infix_expression(programType pType) :{  ASTExpression result;}{  result = term(pType)  {    return result;  }}ASTExpression prefix_expression(programType pType) :{  String operator;  Token op;  ASTExpressionPrefixOperation result;  ASTExpression exp;}{
  (    operator = incrDecrOperators() exp = fragment(pType)
  )
  {
    if (pType == programType.P) throw new ParseException("Not supported in Python!\n");
    result = new ASTExpressionPrefixOperation(operator, exp);
    return result;  }| (    operator = prefixOperators() exp = fragment(pType)  )  {
    if (pType == programType.P && operator != "~" && operator != "not") throw new ParseException("Not supported in Python!\n");	if (pType != programType.P && operator == "not") throw new ParseException("Not supported in C or Java!\n");
    result = new ASTExpressionPrefixOperation(operator, exp);    return result;  }| op = < MINUS > exp = expression(pType)  {    result = new ASTExpressionPrefixOperation(op.image, exp);
    return result;  }}ASTExpression postfix_expression(programType pType) :{  String operator;  Token var;}{  < POST > < VARIABLE > var = < IDENTIFIER > operator = incrDecrOperators()  {
    if (pType == programType.P) throw new ParseException("Not supported in Python!\n");    ASTExpressionUnitIdentifier i = new ASTExpressionUnitIdentifier(var.image);    ASTExpressionPostfixOperation result = new ASTExpressionPostfixOperation(operator, i);    return result;  }}ASTExpression expression(programType pType) :{  ASTExpression result1;  ASTExpression result2;  ASTExpression result3;  ASTExpression result4;}{  (    result1 = prefix_expression(pType)    {      return result1;    }  | result2 = infix_expression(pType)    {      return result2;    }  | result3 = postfix_expression(pType)    {      return result3;    }  )| result4 = assignment(pType)  {    return result4;  }}ASTExpression assignment(programType pType) :{  ASTExpression term;  Token operator;  ASTExpression exp;  String op;}{  < ASSIGNMENT > term = fragment(pType)  {}  (    token = < WITH >    {      op = "=";    }  | op = compoundOperators()  )  exp = expression(pType)  {    ASTExpressionAssignment result = new ASTExpressionAssignment(term, exp, op);    return result;  }}/*Block Statement*/ASTStructDeclaration structDeclareStatement(ASTNode parent, programType pType, int indent) :{  Token name;  ASTDeclarationStatement attribute;}{  < STRUCT_DEC > name = < IDENTIFIER >  {
    if (pType != programType.C) throw new ParseException("Not supported in Python or Java!\n");    ASTStructDeclaration result = new ASTStructDeclaration(name.image);
    result.setIndent(indent);    result.addParent(parent);  }  < STRUCT_START >  (    attribute = create_variable(pType)    {      result.addAttribute((ASTDeclarationStatementC) attribute);     //System.out.println(attribute.toSyntax());    }  )+  < STRUCT_END > < TERMINATOR >  {    return result;  }}ASTFunction functionStatement(ASTNode parent, programType pType, int indent) :{  String modifier;  String returnType;  Token name;  String parameterType = "";  Token parameterName;
  ASTExpressionUnitPointer p;  ASTStatement s;  Token dimension;
  ASTFunction result;}{  < FUNCTION_DEC > name = < IDENTIFIER >  {
    switch (pType) {
      case C:
      	result = new ASTFunctionC(name.image);
      	break;
      case P:
      	result = new ASTFunctionP(name.image);
      	break;
      default:
      	result = new ASTFunction(name.image);
      	break;
    }    result.addParent(parent);
    result.setIndent(indent);  }  (    modifier = catchModifier()    {
      if (pType == programType.P) throw new ParseException("Not supported in Python!\n");      ((ASTFunctionC) result).addModifier(modifier);    }  )*  (    returnType = types_C()    {
      if (pType == programType.P) throw new ParseException("Not supported in Python!\n");      ((ASTFunctionC) result).addReturnType(new ASTExpressionUnitTypes(returnType));    }  )?  (    (      < PARAMETER >
      (        < TYPE > parameterType = types_C()
	    {
	      if (pType == programType.P) throw new ParseException("Not supported in Python!\n");
	    }
      )?
      (        parameterName = < IDENTIFIER >
        {
          if (pType != programType.P && parameterType == "") throw new ParseException("Must declare type in C and Java!\n");
          ASTExpressionUnitTypes t = new ASTExpressionUnitTypes(parameterType);
          ASTExpressionUnitIdentifier i = new ASTExpressionUnitIdentifier(parameterName.image);
          switch (pType) {
            case C:
            	((ASTFunctionC) result).addParameter(t, i);
	      		break;
	      	case P:
	      		((ASTFunctionP) result).addParameter(i);
	      		break;
	     }
	   }
	 | p = pointer(pType)
	   {
	     if(pType != programType.C) throw new ParseException("Not Supported in Java and Python!\n");
	     if(parameterType == "") throw new ParseException("Must declare type in C!\n");
	     t = new ASTExpressionUnitTypes(parameterType);
         i = new ASTExpressionUnitIdentifier(p.toSyntax());
         ((ASTFunctionC) result).addParameter(t, i);
       }
	 )    )  |    (      < PARAMETER_A > < DIMENSION > dimension = < INTEGER_LITERAL > parameterType = types_C() < ARRAY >      {
        if (pType == programType.P) throw new ParseException("Not supported in Python!\n");        ASTExpressionUnitTypesArray type = new ASTExpressionUnitTypesArray(parameterType, Integer.parseInt(dimension.image));      }
      (        parameterName = < IDENTIFIER >
        {
          ASTExpressionUnitIdentifier id = new ASTExpressionUnitIdentifier(parameterName.image);
          ((ASTFunctionC) result).addParameter(type, id);
        }
      | p = pointer(pType)
      	{
      	  id = new ASTExpressionUnitIdentifier(p.toSyntax());
          ((ASTFunctionC) result).addParameter(type, id);
        }
      )    )  )*  < FUNCTION_START >  (    s = statement(result, pType, indent+1)    {
      if (!s.toSyntax().equals("\n"))
      {
        result.addStatement(s);      	//System.out.println(s.toSyntax());
      }    }  )*  < FUNCTION_END > < TERMINATOR >  {    return result;  }}ASTIfStatement if_statement(ASTNode parent, programType pType, int indent) :{  ASTExpression condition;
  ASTExpression elseIfCond;  ASTStatement stat1;  ASTStatement stat2;
  ASTStatement stat3;
  ASTIfStatement result;}{  < IF > < CONDITION > condition = expression(pType)  {
    switch (pType) {
      case C:
      	result = new ASTIfStatementC(condition);
      	break;
      case P:
      	result = new ASTIfStatementP(condition);
      	break;
      default:
      	result = new ASTIfStatement(condition);
      	break;
    }    result.addParent(parent);
    result.setIndent(indent);    //System.out.println(condition.toSyntax());  }  < IF_BRANCH_START >  (    stat1 = statement(result, pType, indent+1)    {      result.setIf(stat1);      //System.out.println(stat1.toSyntax());    }  )*  < IF_BRANCH_END >
  (
    < ELSE > < IF > < CONDITION > elseIfCond = expression(pType)
    {
      result.setElseIfCond(elseIfCond);
    }
    < ELSEIF_BRANCH_START >
    (
      stat2 = statement(result, pType, indent+1)
      {
        result.setElseIf(stat2);
        //System.out.println(stat2.toSyntax());
      }
    )*
    < ELSEIF_BRANCH_END >
  )*  (    < ELSE_BRANCH_START >    (      stat3 = statement(result, pType, indent+1)      {        result.setElse(stat3);        //System.out.println(stat3.toSyntax());      }    )*    < ELSE_BRANCH_END >  )?  < TERMINATOR >  {    return result;  }}ASTForStatement forStatement(ASTNode parent, programType pType, int indent) :
{  ASTForStatement result;
}
{  < FOR >
  (    result = forStatementC(pType, indent)
  |
  	result = forStatementP(pType, indent)
  )
  {
    result.addParent(parent);
    result.setIndent(indent);
    return result;
  }
}
ASTForStatementC forStatementC(programType pType, int indent) :{  ASTExpression init;  ASTExpression end;  ASTExpression increment;  ASTStatement temp;
  ASTForStatementC result = new ASTForStatementC();}{  < CONDITION >
  {
    if (pType == programType.P) throw new ParseException("Not Supported in Python!\n");
  }   (
    init = expression(pType)    {
      result.addInitial(init);      //System.out.println(init.toSyntax());    }  )?
  < CONDITION >  (    end = expression(pType)    {
      result.addFinal(end);      //System.out.println(end.toSyntax());    }  )?
  < CONDITION >   (
    increment = expression(pType)    {
      result.addIncrement(increment);      //System.out.println(increment.toSyntax());    }  )?  < FOR_START >  (    temp = statement(result, pType, indent+1)    {      result.addStatement(temp);      //System.out.println(temp.toSyntax());    }  )*  < FOR_END > < TERMINATOR >  {    return result;  }}

ASTForStatementP forStatementP(programType pType, int indent) :
{
  String variable;
  ASTExpression exp;
  ASTStatement temp;
  ASTForStatementP result = new ASTForStatementP();
}
{
  (    < PARAMETER > variable = variable()
    {
      if (pType != programType.P) throw new ParseException("Not Supported in C or Java!\n");
      result.addVariable(new ASTExpressionUnitIdentifier(variable));
      //System.out.println(init.toSyntax());
    }
  )+
  
  exp = fragment(pType)
  {
  	if (exp instanceof ASTExpressionUnit) result.addExp((ASTExpressionUnit) exp);
    else throw new ParseException("Not Supported in Python!\n");
  	//System.out.println(end.toSyntax());
  }
  < FOR_START >
  (
    temp = statement(result, pType, indent+1)
    {
      result.addStatement(temp);
      //System.out.println(temp.toSyntax());
    }
  )*
  < FOR_END >
  (
    < ELSE_BRANCH_START >
	(
	  temp = statement(result, pType, indent+1)
	  {
	    result.addElseBranch(temp);
	  }
	)*
	< ELSE_BRANCH_END >
  )?
  < TERMINATOR >
  {
    return result;
  }
}ASTWhileStatement whileStatement(ASTNode parent, programType pType, int indent) :{  ASTExpression exp;  ASTStatement temp;
  ASTWhileStatement result;}{  < WHILE > < CONDITION > exp = expression(pType)  {
    switch (pType) {
      case C:
      	result = new ASTWhileStatementC(exp);
      	break;
      case P:
      	result = new ASTWhileStatementP(exp);
      	break;
      default:
      	result = new ASTWhileStatement(exp);
      	break;
    }    result.addParent(parent);
    result.setIndent(indent);    //System.out.println(exp.toSyntax());  }  < WHILE_START >  (    temp = statement(result, pType, indent+1)    {      result.addStatement(temp);      //System.out.println(temp.toSyntax());    }  )*  < WHILE_END >
  (
    < ELSE_BRANCH_START >
	(
	  temp = statement(result, pType, indent+1)
	  {
	    if (pType != programType.P) throw new ParseException("Not Supported in C or Java!\n");
	    ((ASTWhileStatementP) result).addElseBranch(temp);
	  }
	)*
	< ELSE_BRANCH_END >
  )?
  < TERMINATOR >  {    return result;  }}ASTDoWhileStatement doWhileStatement(ASTNode parent, programType pType, int indent) :{  ASTExpression exp;  ASTStatement temp;}{  < DO >
  {
    if (pType == programType.P) throw new ParseException("Not supported in Python!\n");
  }
  < CONDITION > exp = expression(pType)  {    ASTDoWhileStatement result = new ASTDoWhileStatement(exp);    result.addParent(parent);
    result.setIndent(indent);    //System.out.println(exp.toSyntax());  }  < WHILE_START >  (    temp = statement(result, pType, indent+1)    {      result.addStatement(temp);      //System.out.println(temp.toSyntax());    }  )*  < WHILE_END > < TERMINATOR >  {    return result;  }}ASTSwitchStatement switchStatement(ASTNode parent, programType pType, int indent) :{  ASTExpression condition;  ASTExpression case_condition;  ASTStatement temp;}{  < SWITCH > < CONDITION > condition = expression(pType)  {
    if (pType == programType.P) throw new ParseException("Not supported in Python!\n");    ASTSwitchStatement result = new ASTSwitchStatement(condition);    result.addParent(parent);
    result.setIndent(indent);    //System.out.println(condition.toSyntax());  }  (    < CASE > case_condition = expression(pType)    {      result.addCase(case_condition);      //System.out.println(case_condition.toSyntax());    }    < CASE_START >    (      temp = statement(result, pType, indent+1)      {        result.addStatement(temp);        //System.out.println(temp.toSyntax());      }    )*    < CASE_END >  )*  (    < _DEFAULT >    {      result.addDefault();    }    < CASE_START >    (      temp = statement(result, pType, indent+1)      {        result.addStatement(temp);        //System.out.println(temp.toSyntax());      }    )*    < CASE_END >  )?  < TERMINATOR >  {    return result;  }}

ASTComment comment(ASTNode parent, programType pType, int indent) :
{
  ASTStatement temp;
  ASTComment result;
  Token i;
}
{
  < COMMENT >
  {
    switch (pType) {
      case C:
      	result = new ASTCommentC();
      	break;
      case P:
      	result = new ASTCommentP();
      	break;
      default:
      	result = new ASTComment();
      	break;
    }
    result.addParent(parent);
    result.setIndent(indent);
  }
  (    temp = statement(parent, pType, indent)
    { 
      result.addStatement(temp);
    }
  )*
  < COMMENT_END >
  (    i = < INTEGER_LITERAL >
    {
      int numLines = result.getNumLines();
      int line = Integer.parseInt(i.image);
      if(line > numLines) throw new IndexOutOfBoundsException("Index: " + Integer.toString(line-1) + " Size: " + Integer.toString(numLines));
      result.addCommentedOutLine(line-1);
    }
  )*
  <TERMINATOR >
  {
    return result;
  }
}
ASTClass classDeclare(ASTNode parent, programType pType, int indent) :
{
  ASTStatement temp;
  ASTClass result;
  Token name;
  Token parentClass;
  ASTExpressionUnitAccess parentClassAccess;
}
{
  < CLASS > name = < IDENTIFIER >
  {
    switch (pType) {
      case C:
      	throw new ParseException("Not Supported in C!\n");
      	break;
      case P:
      	result = new ASTClassP(name.image);
      	break;
      default:
      	result = new ASTClass(name.image);
      	break;
    }
    result.addParent(parent);
    result.setIndent(indent);
  }
  (    < PARENT >
    (      parentClass = < IDENTIFIER >
	  {
	    ((ASTClassP) result).addInheritance(new ASTExpressionUnitIdentifier(parentClass.image));
	  }
	| parentClassAccess = access(pType)
	  {
	    ((ASTClassP) result).addInheritance(new ASTExpressionUnitIdentifier(parentClassAccess.toSyntax()));
	  }
 	)
  )*
  < CLASS_START >
  (
    temp = statement(parent, pType, indent+1)
    { 
      result.addStatement(temp);
    }
  )*
  < CLASS_END >
  <TERMINATOR >
  {
    return result;
  }
}

ASTTryCatchStatement tryCatchStatement(ASTNode parent, programType pType, int indent) :
{
  ASTStatement temp;
  ASTTryCatchStatement result;
  Token ex;
}
{
  < TRY >
  {
    switch (pType) {
      case C:
      	throw new ParseException("Not Supported in C!\n");
      	break;
      case P:
      	result = new ASTTryCatchStatementP();
      	break;
      default:
      	result = new ASTTryCatchStatement();
      	break;
    }
    result.addParent(parent);
    result.setIndent(indent);
  }
  (
    temp = statement(parent, pType, indent+1)
    { 
      result.addTryBlock(temp);
    }
  )*
  (    < CATCH >
    {
      result.addCatchBlock();
    }
    (      < EXCEPTION > ex = < IDENTIFIER >
      {
        result.addCatchExceptions(new ASTExpressionUnitIdentifier(ex.image));
      }
    )*
    (      < VARIABLE > ex = < IDENTIFIER >
      {
        result.setEx(new ASTExpressionUnitIdentifier(ex.image));
      }
    )?
    < CATCH_START >
    (      temp = statement(parent, pType, indent+1)
      {
        result.addCatchBlocks(temp);
      }
    )*
    < CATCH_END >
  )+
  (    < ELSE >
    {
      if(pType == programType.J) throw new ParseException("Not Supported in Java!\n");
    }
    (      temp = statement(parent, pType, indent+1)
      {
        ((ASTTryCatchStatementP) result).addElseBlock(temp);
      }
    )*
    < ELSE_BRANCH_END >    
  )?
  (    < FINALLY >
    (
      temp = statement(parent, pType, indent+1)
      {
        result.addFinallyBlock(temp);
      }
    )*
    < FINALLY_END >    
  )?
  <TERMINATOR >
  {
    return result;
  }
}

ASTWithStatement withStatement(ASTNode parent, programType pType, int indent) :
{
  Token name;
  ASTWithStatement result;
  ASTExpression withItem;
  ASTStatement statement;
}
{
  < WITH >
  {
    if(pType != programType.P) throw new ParseException("Not supported in C or Java!\n");
    result = new ASTWithStatement();
    result.addParent(parent);
    result.setIndent(indent);
  }
  (    withItem = fragment(pType)
    {
      result.addWithItem((ASTExpressionUnit) withItem);
    }
    (      name = < IDENTIFIER >
      {
        result.addName(name.image);
      }
    )?
  )+
  < WITH_START >
  (    statement = statement(parent, pType, indent+1)
    {
      result.addStatement(statement);
    }
  )*
  < WITH_END > < TERMINATOR >
  {
    return result;
  }
}
/*SimpleStatement*/ASTBreakStatement breakStatement(programType pType) :{  Token n;  ASTBreakStatement result;}{  < BREAK >  {
    switch (pType) {
      case C:
      	result = new ASTBreakStatementC();
      	break;
      case P:
      	result = new ASTBreakStatementP();
      	break;
      default:
      	result = new ASTBreakStatement();
    }  }  (    n = < IDENTIFIER >    {
      if (pType == programType.P) throw new ParseException("Not supported in Python!\n");      ASTExpressionUnitIdentifier label = new ASTExpressionUnitIdentifier(n.image);      ((ASTBreakStatementC) result).setLabel(label);    }  )?  < TERMINATOR >  {    return result;  }}ASTContinueStatement continueStatement(programType pType) :{  Token n;
  ASTContinueStatement result;}{  < CONTINUE > < TERMINATOR >  {
    switch (pType) {
      case C:
      	result = new ASTContinueStatementC();
      	break;
      case P:
      	result = new ASTContinueStatementP();
      	break;
      default:
      	result = new ASTContinueStatement();
    	break; 
    }        return result;  }}ASTReturnStatement returnStatement(programType pType) :{  ArrayList<ASTExpression> expList = new ArrayList<ASTExpression>();
  ASTExpression exp = null;
  ASTReturnStatement result;}{  < RETURN >
  {    switch (pType) {
      case C:
      	result = new ASTReturnStatementC();
      	break;
      case P:
      	result = new ASTReturnStatementP();
      	break;
      default:
      	result = new ASTReturnStatement();
      	break;
    }
  }
  (    < PARAMETER > exp = expression(pType)
    {
      if (pType != programType.P && !expList.isEmpty()) throw new ParseException("Not supported in C or Java!\n");
      expList.add(exp);
    }
  )*  < TERMINATOR >  {
    for (ASTExpression expression : expList) {
      switch (pType) {
      case C:
      	((ASTReturnStatementC) result).addExp(expression);
      	break;
      case P:
      	((ASTReturnStatementP) result).addExp(expression);
      	break;
      default:
      	break;
      }
    }
    return result;
  }}ASTLabelStatement labelStatement(programType pType) :{  Token n;}{  < LABEL > n = < IDENTIFIER > < TERMINATOR >  {
    if (pType == programType.P) throw new ParseException("Not supported in Python!\n");    ASTExpressionUnitIdentifier id = new ASTExpressionUnitIdentifier(n.image);    ASTLabelStatement result = new ASTLabelStatement(id);    return result;  }}
ASTImportStatement importStatement(programType pType) :
{
  ASTImportStatement result;
  ASTExpressionUnitLiteral fromPkg = null;
  ASTExpressionUnitLiteral exp;
  ASTExpressionUnitIdentifier id;
  Token str;
}
{
  (    < FROM > str = < STRING_LITERAL >
    {
      if(pType != programType.P) throw new ParseException("Not supported in C or Java!\n");
      fromPkg = new ASTExpressionUnitLiteral(str.image.substring(1,str.image.length()-1));
    }
  )?
  < INCLUDE > str = < STRING_LITERAL >
  {
    exp = new ASTExpressionUnitLiteral(str.image.substring(1,str.image.length()-1));

    if(fromPkg != null) {
      result = new ASTImportStatementP(fromPkg, true);
      ((ASTImportStatementP) result).addImport(exp);
    }
    else {
      switch (pType) {
        case C:
        	result = new ASTImportStatementC(exp);
	      	break;
	    case P:
	      	result = new ASTImportStatementP(exp, false);
	      	break;
	    default:
	      	result = new ASTImportStatement(exp);
	  }
	}
  }
  (    < AS > str = < IDENTIFIER >
    {
      if(pType != programType.P) throw new ParseException("Not supported in C or Java!\n");
      id = new ASTExpressionUnitIdentifier(str.image);
      ((ASTImportStatementP) result).addAs(id);
    }
  )?
  (    < INCLUDE > str = < STRING_LITERAL >
    {
      if(pType != programType.P) throw new ParseException("Not supported in C or Java!\n");
      exp = new ASTExpressionUnitLiteral(str.image.substring(1,str.image.length()-1));
      ((ASTImportStatementP) result).addImport(exp);
    }
    (      < AS > str = < IDENTIFIER >
      {
        if(pType != programType.P) throw new ParseException("Not supported in C or Java!\n");
        id = new ASTExpressionUnitIdentifier(str.image);
        ((ASTImportStatementP) result).addAs(id);
      }
    )?
  )*
  < TERMINATOR >
  {
    return result;
  }      
}
ASTGoToStatement gotoStatement(programType pType) :{  Token label;}{  < GOTO > label = < IDENTIFIER > < TERMINATOR >  {
    if(pType != programType.C) throw new ParseException("Not supported in Python or Java!\n");    return new ASTGoToStatement(new ASTExpressionUnitIdentifier(label.image));  }}

ASTPassStatement passStatement(programType pType) :
{ }
{  < PASS > < TERMINATOR >
  {
    if(pType != programType.P) throw new ParseException("Not supported in C or Java!\n");    return new ASTPassStatement();
  }
}
ASTTypedefStatement typedefStatement(programType pType) :
{
  String type;
  Token id;}
{
  < TYPEDEF >
  {    if(pType != programType.C) throw new ParseException("Not supported in Python or Java!\n");
  }
  type = types_C()
  id = < IDENTIFIER > < TERMINATOR >
  {    return new ASTTypedefStatement(type, id.image);
  }}

ASTDebugStatement debugStatement() :
{
  Token str;
}
{
  < STRING > str = < STRING_LITERAL > < TERMINATOR >
  {
    return new ASTDebugStatement(str.image);
  }
}
ASTSimpleStatement simpleStatement(programType pType) :
{
  ASTExpression result;
  ASTDeclarationStatement out;
  ASTBreakStatement bs;
  ASTContinueStatement cs;
  ASTLabelStatement label;
  ASTReturnStatement rs;
  ASTImportStatement is;
  ASTGoToStatement gt;
  ASTPassStatement pass;
  ASTTypedefStatement td;
  ASTDebugStatement db;
}
{
  (
    result = expression(pType) < TERMINATOR >
  )
  {
    ASTExpressionStatement output;
    switch (pType) {
      case C:
      	output = new ASTExpressionStatementC(result);
      	break;
      case P:
      	output = new ASTExpressionStatementP(result);
      	break;
      default:
      	output = new ASTExpressionStatement(result);
    }
    return output;
  }
| out = create_variable(pType)
  {
    return out;
  }
| bs = breakStatement(pType)
  {
    return bs;
  }
| cs = continueStatement(pType)
  {
    return cs;
  }
| label = labelStatement(pType)
  {
    return label;
  }
| rs = returnStatement(pType)
  {
    return rs;
  }
| is = importStatement(pType)
  {
    return is;
  }
| gt = gotoStatement(pType)
  {
    return gt;
  }
| pass = passStatement(pType)
  {
    return pass;
  }
| td = typedefStatement(pType)
  {
    return td;
  }
| db = debugStatement()
  {
    return db;
  }
}
ASTBlockStatement blockStatement(ASTNode parent, programType pType, int indent) :{  ASTStructDeclaration structDeclare;  ASTDoWhileStatement doWhile;  ASTForStatement forStatement;  ASTFunction functionDeclare;  ASTIfStatement ifStatement;  ASTWhileStatement whileStatement;  ASTSwitchStatement switchStatement;
  ASTComment comment;
  ASTClass classDeclare;
  ASTTryCatchStatement tryCatchStatement;
  ASTWithStatement withStatement;}{  structDeclare = structDeclareStatement(parent, pType, indent)  {    return structDeclare;  }| doWhile = doWhileStatement(parent, pType, indent)  {    return doWhile;  }| forStatement = forStatement(parent, pType, indent)  {    return forStatement;  }| functionDeclare = functionStatement(parent, pType, indent)  {    return functionDeclare;  }| ifStatement = if_statement(parent, pType, indent)  {    return ifStatement;  }| whileStatement = whileStatement(parent, pType, indent)  {    return whileStatement;  }| switchStatement = switchStatement(parent, pType, indent)  {    return switchStatement;  }
| comment = comment(parent, pType, indent)
  {	return comment;
  }
| classDeclare = classDeclare(parent, pType, indent)
  {    return classDeclare;
  }
| tryCatchStatement = tryCatchStatement(parent, pType, indent)
  {
    return tryCatchStatement;
  }
| withStatement = withStatement(parent, pType, indent)
  {    return withStatement;
  }}ASTStatement query() :{}{  "?"  (    < STRUCT >    {      getStructure(current);      return new ASTStatement();    }  | < TREE >    {      getTree(current);      return new ASTStatement();    }  )}
ASTStatement statement(ASTNode parent, programType pType, int indent) :
{
  ASTStatement result;
}
{
  (    result = simpleStatement(pType)
  | result = blockStatement(parent, pType, indent)
  )
  {
    current = result;
    result.addParent(parent);
    return result;
  }
| query()
  {
    return new ASTStatement();
  }
}
ASTCompilationUnit compilationUnit() :
{
  Token name;
  ASTStatement statement;
  ASTCompilationUnit result;
  programType pType;
}
{
  (
  	< PROGRAM_C > name = < IDENTIFIER >
  	{
    	result = new ASTCompilationUnitC(name.image);
    	pType = programType.C;
  	}
	|
  	< PROGRAM_P > name = < IDENTIFIER >
  	{
    	result = new ASTCompilationUnitP(name.image);
    	pType = programType.P;
  	}
  )
  {    current = result;
  }
  (
    statement = statement(result, pType, 0)
    {
      if (!statement.toSyntax().equals("\n") || statement instanceof ASTDebugStatement)
      {
        result.addStatement(statement);
        current = statement;
        //current.addStatement(statement);
        // important : Outputs to final program
        if(isDebug) System.out.println(statement.toSyntax());
      }
    }
  )+
  < PROGRAM_END >
  {
    return result;
  }
}
ASTCompilationUnit program() :{  ASTCompilationUnit result;}{
  result = compilationUnit()
  {
	current = result;
    System.out.println(result.toSyntax());
    System.out.println(result.toTree(0));
	return result;
  }
}